import { Injectable, Logger } from '@nestjs/common';
import { ApifyService } from '../apify/apify.service';
import type { YoutubeScraperResponse } from './interface';
import {
  RawRedditItemSchema,
  RedditPost,
  RedditScraperConfig,
  YoutubeScraperConfig,
  YoutubeScraperResponseSchema,
  YoutubeTranscriptConfig,
  YoutubeTranscriptResponse,
  YouTubeTranscriptResponseSchema,
} from './interface';
import { ResponseParserService } from '../llm/parsers/responseParser.service';

@Injectable()
export class ActorsService {
  private logger: Logger;
  private videoPerKeyword = 1;
  private numberOfPosts = 2;
  constructor(
    private apifyService: ApifyService,
    private parserService: ResponseParserService,
  ) {
    this.logger = new Logger(ActorsService.name);
  }

  async searchYoutube(keywords: string[]) {
    const actorId = `streamers/youtube-scraper`;
    const input: YoutubeScraperConfig = {
      dateFilter: 'year',
      downloadSubtitles: false,
      hasCC: false,
      hasLocation: false,
      hasSubtitles: false,
      is360: false,
      is3D: false,
      is4K: false,
      isBought: false,
      isHD: false,
      isHDR: false,
      isLive: false,
      isVR180: false,
      lengthFilter: 'between420',
      maxResultStreams: 0,
      maxResults: this.videoPerKeyword,
      maxResultsShorts: 0,
      preferAutoGeneratedSubtitles: false,
      saveSubsToKVS: false,
      searchQueries: keywords,
      sortingOrder: 'views',
    };

    const run = await this.apifyService.startActor(actorId, input);
    const completedRun = await this.apifyService.waitForRun(run.id);
    const datasetItems = await this.apifyService.getDatasetItems(
      completedRun.defaultDatasetId,
    );

    return this.parserService.parseWithSchema<YoutubeScraperResponse>(
      JSON.stringify(datasetItems.items),
      YoutubeScraperResponseSchema,
    );
  }

  async transcribeVideo(videoUrl: string) {
    const actorId = `pintostudio/youtube-transcript-scraper`;
    const input: YoutubeTranscriptConfig = {
      videoUrl,
    };
    const run = await this.apifyService.startActor(actorId, input);
    const completedRun = await this.apifyService.waitForRun(run.id);
    const datasetItems = await this.apifyService.getDatasetItems(
      completedRun.defaultDatasetId,
    );

    return this.parserService.parseWithSchema<YoutubeTranscriptResponse>(
      JSON.stringify(datasetItems.items),
      YouTubeTranscriptResponseSchema,
    );
  }

  async searchReddit(keywords: string[]) {
    const actorId = `jupri/reddit`;
    const input: RedditScraperConfig = {
      dev_dataset_clear: false,
      dev_no_strip: false,
      filters: {
        mode: 'posts',
        safe: false,
        sort: 'RELEVANCE',
        timing: 'month',
        types: ['text'],
      },
      limit: this.numberOfPosts,
      query: keywords,
    };
    const run = await this.apifyService.startActor(actorId, input);
    const completedRun = await this.apifyService.waitForRun(run.id);
    const datasetItems = await this.apifyService.getDatasetItems(
      completedRun.defaultDatasetId,
    );

    const accept: RedditPost[] = datasetItems.items.flatMap((it, index) => {
      const result = RawRedditItemSchema.safeParse(it);
      if (!result.success) {
        this.logger.error(`Error while retrieving reddit item at ${index}`);
        return [];
      }

      return [result.data];
    });

    return accept;
  }
}
